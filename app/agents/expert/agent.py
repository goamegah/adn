"""
Agent 3 : Expert/Contextualisation - ADN (AI Diagnostic Navigator)
'Le Professeur de M√©decine' - Valide avec guidelines et g√©n√®re diagnostics diff√©rentiels
Temps d'ex√©cution : T+90s √† T+120s
"""

import json
from typing import Dict, List, Any
from google.cloud import aiplatform
from vertexai.generative_models import GenerativeModel
from vertexai.preview.generative_models import grounding


class AgentExpert:
    """
    Agent 3 : Expert qui valide les alertes avec des guidelines m√©dicales
    et g√©n√®re des diagnostics diff√©rentiels via RAG
    """
    
    def __init__(self, project_id: str, location: str = "us-central1"):
        self.project_id = project_id
        self.location = location
        aiplatform.init(project=project_id, location=location)
        self.model = GenerativeModel("gemini-2.0-flash")
        
        # Configuration RAG (Vertex AI Search - optionnel si disponible)
        self.rag_disponible = False  # Mettre True si Vertex AI Search configur√©
        self.datastore_id = None  # ID du datastore m√©dical si disponible
    
    def analyser_alertes(self, output_agent2: Dict[str, Any]) -> Dict[str, Any]:
        """
        Point d'entr√©e principal : Analyse l'output de l'Agent 2
        et g√©n√®re des diagnostics diff√©rentiels avec validation
        """
        print("üéì Agent 3 Expert : D√©marrage de l'analyse...")
        
        # Extraction des donn√©es importantes
        synthese = output_agent2.get("synthesis", {})
        alertes = output_agent2.get("critical_alerts", [])
        data_patient = output_agent2.get("source_data", {}).get("patient_normalized", {})
        scores = output_agent2.get("clinical_scores", [])
        
        # Phase 1 : G√©n√©rer les diagnostics diff√©rentiels
        print("\nüìä Phase 1 : G√©n√©ration des diagnostics diff√©rentiels...")
        diagnostics = self._generer_diagnostics_differentiels(
            synthese, alertes, data_patient, scores
        )
        
        # Phase 2 : Valider chaque alerte avec guidelines
        print("\nüìö Phase 2 : Validation avec guidelines m√©dicales...")
        alertes_validees = self._valider_alertes_avec_guidelines(alertes, data_patient)
        
        # Phase 3 : Calculer scores de risque additionnels
        print("\nüéØ Phase 3 : Calcul des scores de risque...")
        scores_risque = self._calculer_scores_risque_additionnels(
            diagnostics, data_patient
        )
        
        # Phase 4 : G√©n√©rer plan d'action sourc√©
        print("\nüíä Phase 4 : G√©n√©ration du plan d'action...")
        plan_action = self._generer_plan_action_source(
            alertes_validees, diagnostics, data_patient
        )
        
        # R√©sultat final
        output = {
            "differential_diagnoses": diagnostics,
            "validated_alerts": alertes_validees,
            "risk_scores": scores_risque,
            "action_plan": plan_action,
            "evidence_summary": self._generer_synthese_preuves(
                diagnostics, alertes_validees
            )
        }
        
        print("\n‚úÖ Agent 3 Expert : Analyse termin√©e")
        
        return output
    
    def _generer_diagnostics_differentiels(
        self, 
        synthese: Dict, 
        alertes: List[Dict], 
        data_patient: Dict,
        scores: List[Dict]
    ) -> List[Dict]:
        """
        G√©n√®re les diagnostics diff√©rentiels en utilisant l'IA
        avec recherche dans les guidelines via RAG si disponible
        """
        
        # Construction du contexte clinique
        contexte_clinique = self._construire_contexte_clinique(
            synthese, alertes, data_patient, scores
        )
        
        prompt_diagnostics = f"""
Tu es un expert en m√©decine d'urgence et infectiologie.

CONTEXTE CLINIQUE COMPLET :
{json.dumps(contexte_clinique, indent=2, ensure_ascii=False)}

Ta mission : G√©n√©rer une liste de diagnostics diff√©rentiels pertinents.

Pour chaque diagnostic, fournis :
1. Le nom du diagnostic
2. La probabilit√© (HIGH/MEDIUM/LOW)
3. Un score de confiance (0.0 √† 1.0)
4. Les crit√®res qui soutiennent ce diagnostic (trouv√©s dans les donn√©es)
5. Les crit√®res qui vont contre ce diagnostic
6. Les examens compl√©mentaires n√©cessaires pour confirmer/infirmer

Format JSON strict :
{{
    "differential_diagnoses": [
        {{
            "diagnosis": "Nom du diagnostic",
            "icd10_code": "Code ICD-10 si applicable",
            "probability": "HIGH/MEDIUM/LOW",
            "confidence_score": 0.85,
            "supporting_evidence": [
                {{
                    "finding": "√âl√©ment clinique",
                    "strength": "DEFINITIVE/STRONG/MODERATE/WEAK",
                    "source": "D'o√π vient cette info"
                }}
            ],
            "contradicting_evidence": [
                {{
                    "finding": "√âl√©ment qui va contre",
                    "impact": "MAJOR/MODERATE/MINOR"
                }}
            ],
            "additional_tests_needed": [
                "Examen 1",
                "Examen 2"
            ],
            "urgency": "IMMEDIATE/URGENT/ROUTINE",
            "typical_presentation": "Description de la pr√©sentation typique",
            "atypical_features": ["Caract√©ristique atypique observ√©e"]
        }}
    ]
}}

Classe les diagnostics par probabilit√© d√©croissante.
Sois exhaustif mais pertinent - inclus les diagnostics graves m√™me si moins probables.
"""
        
        # Avec RAG si disponible
        if self.rag_disponible:
            response = self._query_avec_rag(prompt_diagnostics)
        else:
            response = self.model.generate_content(
                prompt_diagnostics,
                generation_config={"response_mime_type": "application/json"}
            )
        
        result = json.loads(response.text)
        return result.get("differential_diagnoses", [])
    
    def _valider_alertes_avec_guidelines(
        self, 
        alertes: List[Dict], 
        data_patient: Dict
    ) -> List[Dict]:
        """
        Valide chaque alerte critique contre les guidelines m√©dicales
        et ajoute des r√©f√©rences sourc√©es
        """
        
        alertes_validees = []
        
        for alerte in alertes:
            
            prompt_validation = f"""
Tu es un expert en m√©decine bas√©e sur les preuves.

ALERTE √Ä VALIDER :
{json.dumps(alerte, indent=2, ensure_ascii=False)}

CONTEXTE PATIENT :
{json.dumps(data_patient, indent=2, ensure_ascii=False)}

Ta mission : Valider cette alerte contre les guidelines m√©dicales reconnues.

Format JSON :
{{
    "alert_validated": true/false,
    "validation_strength": "STRONG/MODERATE/WEAK",
    "guidelines_references": [
        {{
            "guideline_name": "Nom de la guideline (ex: Surviving Sepsis Campaign 2021)",
            "recommendation": "Recommandation exacte",
            "strength_of_evidence": "HIGH/MODERATE/LOW",
            "source_url": "URL si disponible",
            "quote": "Citation pertinente de la guideline"
        }}
    ],
    "clinical_evidence": [
        {{
            "evidence_type": "RCT/Meta-analysis/Observational/Expert opinion",
            "finding": "R√©sultat de l'√©tude",
            "relevance": "Description de la pertinence pour ce cas"
        }}
    ],
    "action_urgency_validated": "IMMEDIATE/WITHIN_1H/WITHIN_6H/ROUTINE",
    "alternative_approaches": [
        "Approche alternative 1 si la premi√®re n'est pas possible"
    ],
    "contraindications_check": {{
        "contraindications_present": false,
        "details": "V√©rification des contre-indications"
    }}
}}
"""
            
            if self.rag_disponible:
                response = self._query_avec_rag(prompt_validation)
            else:
                response = self.model.generate_content(
                    prompt_validation,
                    generation_config={"response_mime_type": "application/json"}
                )
            
            validation = json.loads(response.text)
            
            # Combiner l'alerte originale avec la validation
            alerte_validee = {
                **alerte,  # Alerte originale
                "validation": validation  # Ajout de la validation
            }
            
            alertes_validees.append(alerte_validee)
        
        return alertes_validees
    
    def _calculer_scores_risque_additionnels(
        self, 
        diagnostics: List[Dict], 
        data_patient: Dict
    ) -> List[Dict]:
        """
        Calcule des scores de risque additionnels bas√©s sur les diagnostics
        """
        
        prompt_scores = f"""
Tu es un expert en scores cliniques et pronostic.

DIAGNOSTICS RETENUS :
{json.dumps(diagnostics[:3], indent=2, ensure_ascii=False)}  # Top 3

DONN√âES PATIENT :
{json.dumps(data_patient, indent=2, ensure_ascii=False)}

Pour chaque diagnostic, calcule les scores de risque pertinents.

Exemples de scores selon le diagnostic :
- Sepsis : APACHE II, SAPS II, mortalit√© pr√©dite
- Infarctus : GRACE, TIMI, risque de d√©c√®s √† 30j
- AVC : NIHSS, ASPECT, risque h√©morragique si thrombolyse
- Embolie pulmonaire : score de Wells, PESI, sPESI

Format JSON :
{{
    "risk_scores": [
        {{
            "diagnosis_related": "Diagnostic concern√©",
            "score_name": "Nom du score",
            "score_value": valeur_num√©rique,
            "interpretation": "Interpr√©tation du score",
            "risk_category": "LOW/INTERMEDIATE/HIGH",
            "predicted_outcomes": {{
                "mortality_30d": "Pourcentage ou cat√©gorie",
                "complications": ["Complication possible 1"],
                "icu_length_of_stay": "Estimation"
            }},
            "components_breakdown": {{"composante": "valeur"}},
            "confidence_in_calculation": "HIGH/MEDIUM/LOW avec justification"
        }}
    ]
}}
"""
        
        response = self.model.generate_content(
            prompt_scores,
            generation_config={"response_mime_type": "application/json"}
        )
        
        result = json.loads(response.text)
        return result.get("risk_scores", [])
    
    def _generer_plan_action_source(
        self,
        alertes_validees: List[Dict],
        diagnostics: List[Dict],
        data_patient: Dict
    ) -> Dict:
        """
        G√©n√®re un plan d'action concret et sourc√©
        """
        
        prompt_action = f"""
Tu es un m√©decin urgentiste qui cr√©e un plan d'action concret.

ALERTES VALID√âES :
{json.dumps(alertes_validees, indent=2, ensure_ascii=False)}

DIAGNOSTICS DIFF√âRENTIELS :
{json.dumps(diagnostics[:3], indent=2, ensure_ascii=False)}

DONN√âES PATIENT :
{json.dumps(data_patient, indent=2, ensure_ascii=False)}

Cr√©e un plan d'action structur√© et prioris√©.

Format JSON :
{{
    "immediate_actions": [
        {{
            "action": "Action √† prendre MAINTENANT (< 15 min)",
            "justification": "Pourquoi c'est urgent",
            "guideline_reference": "R√©f√©rence guideline",
            "expected_outcome": "R√©sultat attendu",
            "monitoring": "Comment surveiller l'effet"
        }}
    ],
    "urgent_actions": [
        {{
            "action": "Action dans l'heure",
            "timeframe": "< 1h",
            "justification": "Justification",
            "guideline_reference": "R√©f√©rence"
        }}
    ],
    "diagnostic_workup": [
        {{
            "test": "Examen √† r√©aliser",
            "indication": "Pourquoi",
            "priority": "HIGH/MEDIUM/LOW",
            "expected_turnaround": "D√©lai de r√©sultat",
            "interpretation_guide": "Comment interpr√©ter"
        }}
    ],
    "monitoring_plan": [
        {{
            "parameter": "Param√®tre √† surveiller",
            "frequency": "Fr√©quence de surveillance",
            "alert_threshold": "Seuil d'alerte",
            "escalation_if": "Quand escalader"
        }}
    ],
    "consultation_needs": [
        {{
            "specialty": "Sp√©cialit√© √† consulter",
            "urgency": "IMMEDIATE/URGENT/ROUTINE",
            "reason": "Raison de la consultation",
            "questions_to_address": ["Question 1"]
        }}
    ],
    "medication_adjustments": [
        {{
            "medication": "M√©dicament",
            "action": "START/STOP/ADJUST",
            "dosing": "Posologie recommand√©e",
            "monitoring_required": "Surveillance n√©cessaire",
            "guideline_reference": "R√©f√©rence"
        }}
    ],
    "disposition": {{
        "recommended_location": "USI/USC/√âtage/Domicile",
        "justification": "Justification de l'orientation",
        "criteria_for_discharge": ["Crit√®re pour sortie si applicable"],
        "follow_up_plan": "Plan de suivi"
    }}
}}
"""
        
        response = self.model.generate_content(
            prompt_action,
            generation_config={"response_mime_type": "application/json"}
        )
        
        return json.loads(response.text)
    
    def _construire_contexte_clinique(
        self,
        synthese: Dict,
        alertes: List[Dict],
        data_patient: Dict,
        scores: List[Dict]
    ) -> Dict:
        """
        Construit un contexte clinique structur√© pour l'IA
        """
        return {
            "presentation_clinique": synthese.get("summary", ""),
            "problemes_principaux": synthese.get("key_problems", []),
            "severite": synthese.get("severity", ""),
            "trajectoire": synthese.get("clinical_trajectory", ""),
            "alertes_critiques": [
                {
                    "type": a.get("type"),
                    "finding": a.get("finding"),
                    "severity": a.get("severity")
                }
                for a in alertes
            ],
            "donnees_patient": {
                "age": data_patient.get("age"),
                "sexe": data_patient.get("sex"),
                "antecedents": data_patient.get("medical_history", {}).get("known_conditions", []),
                "medicaments": data_patient.get("medications_current", []),
                "signes_vitaux": data_patient.get("vitals_current", {}),
                "laboratoire": data_patient.get("labs", []),
                "microbiologie": data_patient.get("cultures", [])
            },
            "scores_cliniques": scores
        }
    
    def _generer_synthese_preuves(
        self,
        diagnostics: List[Dict],
        alertes_validees: List[Dict]
    ) -> Dict:
        """
        G√©n√®re une synth√®se des preuves et r√©f√©rences
        """
        
        # Extraire toutes les r√©f√©rences
        toutes_references = []
        
        for alerte in alertes_validees:
            if "validation" in alerte:
                refs = alerte["validation"].get("guidelines_references", [])
                toutes_references.extend(refs)
        
        # D√©duplication et tri
        references_uniques = []
        vues = set()
        for ref in toutes_references:
            nom = ref.get("guideline_name", "")
            if nom not in vues:
                vues.add(nom)
                references_uniques.append(ref)
        
        return {
            "total_references": len(references_uniques),
            "guidelines_cited": references_uniques,
            "evidence_strength_summary": {
                "high_quality": len([r for r in references_uniques if r.get("strength_of_evidence") == "HIGH"]),
                "moderate_quality": len([r for r in references_uniques if r.get("strength_of_evidence") == "MODERATE"]),
                "low_quality": len([r for r in references_uniques if r.get("strength_of_evidence") == "LOW"])
            },
            "key_recommendations": [
                ref.get("recommendation")
                for ref in references_uniques[:5]  # Top 5
            ]
        }
    
    def _query_avec_rag(self, prompt: str) -> Any:
        """
        Effectue une requ√™te avec RAG (Vertex AI Search)
        UNIQUEMENT si configur√©
        """
        
        if not self.rag_disponible or not self.datastore_id:
            # Fallback sur g√©n√©ration normale
            return self.model.generate_content(
                prompt,
                generation_config={"response_mime_type": "application/json"}
            )
        
        # Configuration du grounding avec Vertex AI Search
        grounding_source = grounding.VertexAISearch(
            datastore=self.datastore_id,
            project=self.project_id,
            location=self.location
        )
        
        # G√©n√©ration avec grounding
        response = self.model.generate_content(
            prompt,
            generation_config={
                "response_mime_type": "application/json",
                "grounding": grounding_source
            }
        )
        
        return response


# ============================================================================
# FONCTION D'AFFICHAGE D√âTAILL√â
# ============================================================================

def afficher_resultats_agent3(resultat: Dict, titre: str = "Agent 3 - Expert"):
    """
    Affiche les r√©sultats de l'Agent 3 de mani√®re structur√©e
    """
    print("\n" + "="*100)
    print(f"üéì {titre}")
    print("="*100)
    
    # 1. DIAGNOSTICS DIFF√âRENTIELS
    diagnostics = resultat.get("differential_diagnoses", [])
    print("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    print(f"‚îÇ  üîç DIAGNOSTICS DIFF√âRENTIELS - {len(diagnostics)} identifi√©(s)    ‚îÇ")
    print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    
    for i, diag in enumerate(diagnostics, 1):
        prob_emoji = "üî¥" if diag.get("probability") == "HIGH" else "üü°" if diag.get("probability") == "MEDIUM" else "üü¢"
        print(f"\n{prob_emoji} DIAGNOSTIC #{i} - {diag.get('diagnosis', 'N/A')}")
        print(f"   Code ICD-10 : {diag.get('icd10_code', 'N/A')}")
        print(f"   Probabilit√© : {diag.get('probability', 'N/A')}")
        print(f"   Score confiance : {diag.get('confidence_score', 0):.2f}")
        print(f"   Urgence : {diag.get('urgency', 'N/A')}")
        
        evidence_for = diag.get("supporting_evidence", [])
        if evidence_for:
            print(f"\n   ‚úÖ Arguments POUR ({len(evidence_for)}) :")
            for ev in evidence_for[:3]:  # Top 3
                print(f"      ‚Ä¢ {ev.get('finding')} (force: {ev.get('strength')})")
        
        evidence_against = diag.get("contradicting_evidence", [])
        if evidence_against:
            print(f"\n   ‚ùå Arguments CONTRE ({len(evidence_against)}) :")
            for ev in evidence_against[:2]:
                print(f"      ‚Ä¢ {ev.get('finding')} (impact: {ev.get('impact')})")
        
        tests = diag.get("additional_tests_needed", [])
        if tests:
            print(f"\n   üî¨ Examens n√©cessaires : {', '.join(tests)}")
    
    # 2. ALERTES VALID√âES
    alertes_val = resultat.get("validated_alerts", [])
    print("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    print(f"‚îÇ  ‚úÖ ALERTES VALID√âES - {len(alertes_val)} alerte(s)                 ‚îÇ")
    print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    
    for alerte in alertes_val:
        validation = alerte.get("validation", {})
        validated = validation.get("alert_validated", False)
        strength = validation.get("validation_strength", "N/A")
        
        emoji = "‚úÖ" if validated else "‚ö†Ô∏è"
        print(f"\n{emoji} {alerte.get('type', 'N/A')}")
        print(f"   Validation : {validated} (force: {strength})")
        print(f"   Urgence valid√©e : {validation.get('action_urgency_validated', 'N/A')}")
        
        guidelines = validation.get("guidelines_references", [])
        if guidelines:
            print(f"\n   üìö Guidelines r√©f√©renc√©es ({len(guidelines)}) :")
            for guide in guidelines[:2]:  # Top 2
                print(f"      ‚Ä¢ {guide.get('guideline_name')}")
                print(f"        ‚Üí {guide.get('recommendation', '')[:100]}...")
    
    # 3. PLAN D'ACTION
    plan = resultat.get("action_plan", {})
    print("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    print("‚îÇ  üíä PLAN D'ACTION                                            ‚îÇ")
    print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    
    immediate = plan.get("immediate_actions", [])
    if immediate:
        print(f"\nüö® ACTIONS IMM√âDIATES ({len(immediate)}) :")
        for action in immediate:
            print(f"   ‚Ä¢ {action.get('action')}")
            print(f"     ‚Ü≥ {action.get('justification')}")
    
    urgent = plan.get("urgent_actions", [])
    if urgent:
        print(f"\n‚è∞ ACTIONS URGENTES ({len(urgent)}) :")
        for action in urgent:
            print(f"   ‚Ä¢ {action.get('action')} ({action.get('timeframe')})")
    
    monitoring = plan.get("monitoring_plan", [])
    if monitoring:
        print(f"\nüìä SURVEILLANCE ({len(monitoring)}) :")
        for item in monitoring[:3]:
            print(f"   ‚Ä¢ {item.get('parameter')} - {item.get('frequency')}")
    
    # 4. SYNTH√àSE DES PREUVES
    evidence = resultat.get("evidence_summary", {})
    print("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    print("‚îÇ  üìö SYNTH√àSE DES PREUVES                                     ‚îÇ")
    print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    
    print(f"\n   Total r√©f√©rences : {evidence.get('total_references', 0)}")
    
    strength_summary = evidence.get("evidence_strength_summary", {})
    print(f"\n   Qualit√© des preuves :")
    print(f"      ‚Ä¢ Haute : {strength_summary.get('high_quality', 0)}")
    print(f"      ‚Ä¢ Moyenne : {strength_summary.get('moderate_quality', 0)}")
    print(f"      ‚Ä¢ Basse : {strength_summary.get('low_quality', 0)}")
    
    # 5. JSON COMPLET
    print("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    print("‚îÇ  üìÑ OUTPUT JSON COMPLET                                      ‚îÇ")
    print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    print("\n```json")
    print(json.dumps(resultat, indent=2, ensure_ascii=False))
    print("```")
    
    print("\n" + "="*100 + "\n")


# ============================================================================
# EXEMPLE D'UTILISATION
# ============================================================================

if __name__ == "__main__":
    
    # Simuler l'output de l'Agent 2
    output_agent2_exemple = {
        "synthesis": {
            "summary": "Femme de 70 ans, sepsis s√©v√®re avec h√©moculture positive √† SARM",
            "key_problems": ["Sepsis s√©v√®re", "MRSA bacteremia", "Elevated lactate"],
            "severity": "HIGH",
            "clinical_trajectory": "DETERIORATING"
        },
        "critical_alerts": [
            {
                "type": "CULTURE_NON_TRAITEE",
                "severity": "CRITICAL",
                "finding": "H√©moculture positive √† SARM depuis 12h",
                "source": "blood_culture_2024-10-14",
                "clinical_impact": "Sepsis non contr√¥l√©, risque de choc septique",
                "action_required": "Vancomycine ou Linezolid URGENT"
            },
            {
                "type": "HYPOPERFUSION_TISSULAIRE",
                "severity": "HIGH",
                "finding": "Lactate √©lev√© (3.2) non adress√©",
                "clinical_impact": "Hypoperfusion tissulaire",
                "action_required": "Remplissage vasculaire 30ml/kg"
            }
        ],
        "source_data": {
            "patient_normalized": {
                "age": 70,
                "sex": "femme",
                "medical_history": {
                    "known_conditions": ["Hypertension", "Diab√®te Type 2"]
                },
                "vitals_current": {
                    "temperature": 38.5,
                    "heart_rate": 110,
                    "blood_pressure": "145/92"
                },
                "labs": [
                    {"name": "WBC", "value": 18000, "flag": "HIGH"},
                    {"name": "Lactate", "value": 3.2, "flag": "HIGH"}
                ],
                "cultures": [
                    {
                        "status": "POSITIVE",
                        "organism": "MRSA",
                        "resulted": "2024-10-14T14:30:00"
                    }
                ]
            }
        },
        "clinical_scores": [
            {"score_name": "qSOFA", "value": 2, "interpretation": "Risque √©lev√©"}
        ]
    }
    
    # Initialiser l'Agent 3
    agent3 = AgentExpert(project_id="ai-diagnostic-navigator-475316")
    
    # Analyser
    print("="*80)
    print("TEST AGENT 3 : Expert/RAG")
    print("="*80)
    
    resultat_agent3 = agent3.analyser_alertes(output_agent2_exemple)
    
    # Afficher les r√©sultats
    afficher_resultats_agent3(resultat_agent3, "Sepsis SARM - Validation Expert")